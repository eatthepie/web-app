import { useCallback, useMemo } from 'react'
import { ContractFunctionExecutionError, parseEther } from 'viem'
import { usePublicClient, useWaitForTransactionReceipt, useWriteContract } from 'wagmi'

import lotteryABI from '@/abi/LotteryABI.json'
import { CONTRACT_ADDRESS } from '@/utils/constants'

interface UseLotteryPurchaseProps {
  address?: string
  ticketCount: number
  isAutoGenerated: boolean
  manualNumbers: number[][]
  lotteryInfo?: {
    ticketPrice: string
  }
  generateRandomNumbers: () => number[]
  showToast: (message: string) => void
}

interface UseLotteryPurchaseReturn {
  handlePurchase: () => Promise<void>
  transactionStatus: string
  isConfirming: boolean
  isConfirmed: boolean
  transactionHash?: string
  error?: Error | null
  reset: () => void
}

const ERROR_MESSAGES = {
  INVALID_NUMBERS: 'invalid numbers',
  INSUFFICIENT_FUNDS: 'insufficient funds',
  TICKET_COUNT: 'ticket count',
  USER_DENIED: 'user denied transaction signature',
} as const

const TOAST_MESSAGES = {
  [ERROR_MESSAGES.INVALID_NUMBERS]: '⚠️ Invalid ticket numbers',
  [ERROR_MESSAGES.INSUFFICIENT_FUNDS]: '⚠️ Insufficient funds',
  [ERROR_MESSAGES.TICKET_COUNT]: '⚠️ Max 100 tickets per purchase',
  [ERROR_MESSAGES.USER_DENIED]: '⚠️ Transaction cancelled',
  DEFAULT: '⚠️ Transaction failed. Please try again',
} as const

export default function useLotteryPurchase({
  address,
  ticketCount,
  isAutoGenerated,
  manualNumbers,
  lotteryInfo,
  generateRandomNumbers,
  showToast,
}: UseLotteryPurchaseProps): UseLotteryPurchaseReturn {
  const publicClient = usePublicClient()

  const {
    writeContract,
    data: hash,
    status: transactionStatus,
    error: writeError,
    reset,
  } = useWriteContract()

  const {
    isLoading: isConfirming,
    isSuccess: isConfirmed,
    error: confirmError,
  } = useWaitForTransactionReceipt({ hash })

  const handleError = useCallback(
    (err: unknown) => {
      if (err instanceof ContractFunctionExecutionError) {
        const errorMessage = err.message.toLowerCase()

        // Check for specific error messages and show corresponding toast
        for (const [, value] of Object.entries(ERROR_MESSAGES)) {
          if (errorMessage.includes(value)) {
            showToast(TOAST_MESSAGES[value as keyof typeof ERROR_MESSAGES])
            return
          }
        }

        showToast(TOAST_MESSAGES.DEFAULT)
      } else if (err instanceof Error && err.message.includes(ERROR_MESSAGES.USER_DENIED)) {
        showToast(TOAST_MESSAGES[ERROR_MESSAGES.USER_DENIED])
      } else {
        showToast(TOAST_MESSAGES.DEFAULT)
      }
    },
    [showToast],
  )

  const tickets = useMemo(() => {
    if (isAutoGenerated) {
      return Array(ticketCount).fill(0).map(generateRandomNumbers)
    }
    return manualNumbers
  }, [isAutoGenerated, ticketCount, manualNumbers, generateRandomNumbers])

  const handlePurchase = useCallback(async () => {
    if (!lotteryInfo?.ticketPrice || !address || !publicClient) return

    const value = parseEther(lotteryInfo.ticketPrice) * BigInt(ticketCount)

    try {
      const { request } = await publicClient.simulateContract({
        address: CONTRACT_ADDRESS,
        abi: lotteryABI,
        functionName: 'buyTickets',
        args: [tickets],
        value,
        account: address as `0x${string}`,
      })
      writeContract(request)
    } catch (err) {
      handleError(err)
    }
  }, [address, lotteryInfo, publicClient, ticketCount, tickets, writeContract, handleError])

  return {
    handlePurchase,
    transactionStatus,
    isConfirming,
    isConfirmed,
    transactionHash: hash,
    error: writeError || confirmError,
    reset,
  }
}
