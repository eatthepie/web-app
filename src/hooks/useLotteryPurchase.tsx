import { useCallback, useMemo } from 'react'
import { SignatureTransfer } from '@uniswap/permit2-sdk'
import { ContractFunctionExecutionError, maxUint256 } from 'viem'
import {
  usePublicClient,
  useSignTypedData,
  useWaitForTransactionReceipt,
  useWriteContract,
} from 'wagmi'

import erc20ABI from '@/abi/ERC20ABI.json'
import lotteryABI from '@/abi/LotteryABI.json'
import { CONTRACT_ADDRESS, PERMIT2_ADDRESS, TOKEN_ADDRESS } from '@/utils/constants'

interface UseLotteryPurchaseProps {
  address?: string
  ticketCount: number
  isAutoGenerated: boolean
  manualNumbers: number[][]
  lotteryInfo?: {
    ticketPrice: string
  }
  generateRandomNumbers: () => number[]
  showToast: (message: string) => void
}

interface UseLotteryPurchaseReturn {
  handlePurchase: () => Promise<void>
  transactionStatus: string
  isConfirming: boolean
  isConfirmed: boolean
  transactionHash?: string
  error?: Error | null
  reset: () => void
}

const ERROR_MESSAGES = {
  INVALID_NUMBERS: 'invalid numbers',
  INSUFFICIENT_TOKENS: 'insufficient token balance',
  TRANSFER_FROM_FAILED: 'transfer_from_failed',
  TICKET_COUNT: 'ticket count',
  USER_DENIED: 'user denied transaction signature',
  PERMIT_FAILED: 'permit2 signature failed',
} as const

const TOAST_MESSAGES = {
  [ERROR_MESSAGES.INVALID_NUMBERS]: '⚠️ Invalid ticket numbers',
  [ERROR_MESSAGES.INSUFFICIENT_TOKENS]: '⚠️ Insufficient tokens',
  [ERROR_MESSAGES.TRANSFER_FROM_FAILED]: '⚠️ Transfer failed. Check token balance',
  [ERROR_MESSAGES.TICKET_COUNT]: '⚠️ Max 100 tickets per purchase',
  [ERROR_MESSAGES.USER_DENIED]: '⚠️ Transaction cancelled',
  [ERROR_MESSAGES.PERMIT_FAILED]: '⚠️ Permission signature failed',
  DEFAULT: '⚠️ Transaction failed. Please try again',
} as const

export default function useLotteryPurchase({
  address,
  ticketCount,
  isAutoGenerated,
  manualNumbers,
  lotteryInfo,
  generateRandomNumbers,
  showToast,
}: UseLotteryPurchaseProps): UseLotteryPurchaseReturn {
  const publicClient = usePublicClient()
  const { signTypedDataAsync } = useSignTypedData()
  const {
    writeContractAsync,
    data: hash,
    status: transactionStatus,
    error: writeError,
    reset,
  } = useWriteContract()

  const { writeContractAsync: writeContractAsyncB } = useWriteContract()

  const {
    isLoading: isConfirming,
    isSuccess: isConfirmed,
    error: confirmError,
  } = useWaitForTransactionReceipt({ hash })

  const handleError = useCallback(
    (err: unknown) => {
      if (err instanceof ContractFunctionExecutionError) {
        const errorMessage = err.message.toLowerCase()

        for (const [, value] of Object.entries(ERROR_MESSAGES)) {
          if (errorMessage.includes(value)) {
            showToast(TOAST_MESSAGES[value as keyof typeof TOAST_MESSAGES])
            return
          }
        }

        showToast(TOAST_MESSAGES.DEFAULT)
      } else if (err instanceof Error && err.message.includes(ERROR_MESSAGES.USER_DENIED)) {
        showToast(TOAST_MESSAGES[ERROR_MESSAGES.USER_DENIED])
      } else {
        showToast(TOAST_MESSAGES.DEFAULT)
      }
    },
    [showToast],
  )

  const tickets = useMemo(() => {
    if (isAutoGenerated) {
      const uniqueTickets = new Set()
      const result = []

      while (result.length < ticketCount) {
        const newTicket = generateRandomNumbers()
        const ticketKey = newTicket.join(',')

        if (!uniqueTickets.has(ticketKey)) {
          uniqueTickets.add(ticketKey)
          result.push(newTicket)
        }
      }

      return result
    }
    return manualNumbers
  }, [isAutoGenerated, ticketCount, manualNumbers, generateRandomNumbers])

  const generatePermit2Signature = useCallback(
    async (amount: bigint) => {
      if (!address || !publicClient) throw new Error('Wallet not connected')

      const chainId = await publicClient.getChainId()
      const nonce = BigInt(Math.floor(Math.random() * 1000000))

      const permit = {
        permitted: {
          token: TOKEN_ADDRESS,
          amount: amount,
        },
        spender: CONTRACT_ADDRESS,
        nonce,
        deadline: maxUint256,
      }

      const { domain, types, values } = SignatureTransfer.getPermitData(
        permit,
        PERMIT2_ADDRESS,
        chainId,
      )

      try {
        const signature = await signTypedDataAsync({
          domain: {
            name: domain.name,
            version: domain.version,
            chainId: chainId,
            verifyingContract: domain.verifyingContract as `0x${string}`,
          },
          types,
          primaryType: 'PermitTransferFrom',
          message: values as unknown as Record<string, unknown>,
        })

        return { signature, permit }
      } catch (error) {
        throw new Error(ERROR_MESSAGES.PERMIT_FAILED)
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [address, publicClient],
  )

  const handlePurchase = useCallback(async () => {
    if (!lotteryInfo?.ticketPrice || !address || !publicClient) return

    const TICKET_PRICE = BigInt(lotteryInfo.ticketPrice) * BigInt(1e18)
    const totalCost = TICKET_PRICE * BigInt(ticketCount)

    try {
      // Check token allowance for Permit2
      const allowance = (await publicClient.readContract({
        address: TOKEN_ADDRESS,
        abi: erc20ABI,
        functionName: 'allowance',
        args: [address as `0x${string}`, PERMIT2_ADDRESS],
      })) as bigint

      console.log('allowance', allowance)
      // Approve Permit2 if needed
      if (allowance < totalCost) {
        const { request: approveRequest } = await publicClient.simulateContract({
          address: TOKEN_ADDRESS,
          abi: erc20ABI,
          functionName: 'approve',
          args: [PERMIT2_ADDRESS, maxUint256],
          account: address as `0x${string}`,
        })

        const approveHash = await writeContractAsyncB(approveRequest)
        // Wait for approval transaction to be confirmed
        await publicClient.waitForTransactionReceipt({ hash: approveHash })
      }

      // Generate Permit2 signature
      const { signature, permit } = await generatePermit2Signature(totalCost)

      // Buy tickets
      const { request } = await publicClient.simulateContract({
        address: CONTRACT_ADDRESS,
        abi: lotteryABI,
        functionName: 'buyTickets',
        args: [tickets, permit, signature],
        account: address as `0x${string}`,
      })
      writeContractAsync(request)
    } catch (err) {
      handleError(err)
    }
  }, [
    address,
    lotteryInfo,
    publicClient,
    ticketCount,
    tickets,
    writeContractAsync,
    writeContractAsyncB,
    generatePermit2Signature,
    handleError,
  ])

  return {
    handlePurchase,
    transactionStatus,
    isConfirming,
    isConfirmed,
    transactionHash: hash,
    error: writeError || confirmError,
    reset,
  }
}
